[
  {
    "objectID": "seals_walkthrough_marked.html#getting-set-up",
    "href": "seals_walkthrough_marked.html#getting-set-up",
    "title": "",
    "section": "Getting set up",
    "text": "Getting set up\n\n\nMake sure you have followed all of the steps in the installation page.\n\nIn particular, Clone the SEALS and Hazelbean repositories in the correct location, as described here\nYou will know you’ve got them installed correctly if your VS Code Explorer tab shows the repositories without an error message (Figure 1)"
  },
  {
    "objectID": "seals_walkthrough_marked.html#explore-the-seals-code",
    "href": "seals_walkthrough_marked.html#explore-the-seals-code",
    "title": "",
    "section": "Explore the SEALS code",
    "text": "Explore the SEALS code\n\n\nIn the VS Code Explorer tab, navigate to your seals_dev directory (Figure 1)\n\nQuick note about file organization\n\nThe root directory of seals_dev contains more than just the seals library, such as directories for scripts, images, etc.\nThe library itself is in the seals subdirectory seals_dev/seals which may seem redundant but is necessary for the way Python imports work.\nIf you inspect the seals directory, you will see an __init__.py file. This make Python able to import the directory as a package.\n\nYou will also see a seals_main.py file. This is where most of the actual logic of seals is."
  },
  {
    "objectID": "seals_walkthrough_marked.html#run-files",
    "href": "seals_walkthrough_marked.html#run-files",
    "title": "",
    "section": "Run files",
    "text": "Run files\n\n\n\n\nOne does not simply run a main.py (Figure 1)\n\nInstead, we’re going to have a “run file” that sets up the code and then runs the seals_main.py file\nOpen up the run_test_standard.py file in the seals directory (Figure 2)\n\nWe will setup this file and then finally run it (in debug mode via the launch configs in the earth_economy_devstack repository)"
  },
  {
    "objectID": "seals_walkthrough_marked.html#setting-up-the-run-file",
    "href": "seals_walkthrough_marked.html#setting-up-the-run-file",
    "title": "",
    "section": "Setting up the run file",
    "text": "Setting up the run file\n::: r-fit-text - The run file begins with standard python imports - Then in the if __name__ == '__main__': block, we define the project directory and initialize the project flow object - The reason for putting it in this block is so that you don’t accidentally run the code when you import the file in another script - This file then creates a ProjectFlow objected, assigned to the variable p. - Python is an object-oriented programming langage - The hb.ProjectFlow() defines a class, which is like a recipe for an object - When we call it, it generates on object of that class, which we assign to the variable p\nimport os, sys\nimport seals_utils\nimport seals_initialize_project\nimport hazelbean as hb\nimport pandas as pd\n\nmain = ''\nif __name__ == '__main__':\n:::\n\n## Directories and project name\n\n::: r-fit-text\n-   SEALS (and the EE Devstack) assumes (or softly requires) that you put all code and data somewhere relative to the user's home directory `os.path.expanduser('~')`\n    -   Can put it in sub-directories with `extra_dirs = ['Files', 'seals', 'projects']`\n-   If you followed the EE method, you will have already created the `seals` directory at `&lt;user_dir&gt;/Files/seals`\n    -   In the `seals` directory, your code is in `seals_dev`\n    -   In the `seals` directory, you also will have a `projects` directory\n        -   This is created automatically if its not there\n        -   All data and outputs will be saved in this directory\n            -   As a best practice, you should not save data in the `seals_dev` directory\n-   Given the directory structure above, p.project_name will also be use\n\n:::\n\n\n\n\n# files that already exist. \np.user_dir = os.path.expanduser('~')        \n::: r-fit-text\np.extra_dirs = ['Files', 'seals', 'projects']\np.project_name = 'test_examples'\np.project_name = p.project_name + '_' + hb.pretty_time() # If don't you want to recreate everything each time, comment out this line.\n:::\n\n# Based on the paths above, set the project_dir. All files will be created in this directory.\np.project_dir = os.path.join(p.user_dir, os.sep.join(p.extra_dirs), p.project_name)\np.set_project_dir(p.project_dir)"
  },
  {
    "objectID": "seals_walkthrough_marked.html#using-objects",
    "href": "seals_walkthrough_marked.html#using-objects",
    "title": "",
    "section": "Using Objects",
    "text": "Using Objects\n\n\nThe p object we created will organize input variables (called attributes when assigned to an object)\n\nLike this: p.attribute_name = 'ItsName'\n\nThe p object also has functions tied specificially to it (called methods when assigned to an object)\n\nSuch as: p.validate_name()\nMethods operate on the object that defined it\n\nSo validate_name() is specifically looking at the p object, often doing something to the p object, like fixing value of p.attribute_name"
  },
  {
    "objectID": "seals_walkthrough_marked.html#scenario-definitions-csv",
    "href": "seals_walkthrough_marked.html#scenario-definitions-csv",
    "title": "",
    "section": "Scenario definitions CSV",
    "text": "Scenario definitions CSV\n\n\nThe scenario_definitions file specifies what defines the many different scenarios you want to run\n\nEach row will be one scenario\nEach time the model runs a new scenario, it will update its attributes based on this row\n\nIf you haven’t run SEALS yet, you won’t have a scenario_defintions file, so it will download the default one on the first run\n\n    p.scenario_definitions_filename = 'test_standard_scenarios.csv' \n    p.scenario_definitions_path = os.path.join(p.input_dir, p.scenario_definitions_filename)\n    seals_initialize_project.initialize_scenario_definitions(p)"
  },
  {
    "objectID": "seals_walkthrough_marked.html#scenario-types",
    "href": "seals_walkthrough_marked.html#scenario-types",
    "title": "",
    "section": "Scenario types",
    "text": "Scenario types\n\nScenario type determines if it is historical (baseline) or future (anything else) as well as what the scenario should be compared against. I.e., Policy minus BAU.\n\np.scenario_type = 'bau'"
  },
  {
    "objectID": "seals_walkthrough_marked.html#automatically-downloading-data",
    "href": "seals_walkthrough_marked.html#automatically-downloading-data",
    "title": "",
    "section": "Automatically downloading data",
    "text": "Automatically downloading data\n\n\nThis computing stack also uses hazelbean to automatically download needed data at run time.\n\nIn the code block below, we set p.base_data_dir to a location where we want to store lots of very large files.\nHazelbean will look here for certain files that are necessary and will download them from a cloud bucket if they are not present. T\nThis also lets you use the same base data across different projects.\n\nThe final directory has to be named base_data to match the naming convention on the google cloud bucket.\n\np.base_data_dir = os.path.join('Files/base_data')"
  },
  {
    "objectID": "seals_walkthrough_marked.html#running-the-model",
    "href": "seals_walkthrough_marked.html#running-the-model",
    "title": "",
    "section": "Running the model",
    "text": "Running the model\n\nAfter doing the above steps, you should be ready to run run_test_seals.py. Upon starting, SEALS will report the “task tree” of steps that it will compute in the ProjectFlow environment. To understand SEALS in more depth, inspect each of the functions that define these tasks for more documention in the code.\nOnce the model is complete, go to your project directory, and then the intermediate directory. There you will see one directory for each of the tasks in the task tree. To get the final produce, go to the stitched_lulc_simplified_scenarios directory. There you will see the base_year lulc and the newly projected lulc map for the future year:\n[THIS IS NOT THE CORRECT IMAGE]"
  },
  {
    "objectID": "installation.html#basic-installation",
    "href": "installation.html#basic-installation",
    "title": "",
    "section": "1. Basic Installation",
    "text": "1. Basic Installation\nHazelbean is the computational core of the devstack and can be installed using condaforge following these steps. See the Installing Git and Miniforge3 video for a walkthrough.\n\nInstall git: https://Git-scm.com/downloads\nInstall Miniforge3 from https://conda-forge.org/download/\n\nInstall just for your User Account\nDuring installation, select yes for “Add Mambaforge/Miniforge to my PATH environment Variable”\n\nCreate a new conda environment, activate it, and then install required packages with the following 3 mamba commands. The third command will take quite a while (10+ minutes). The conda init command may not be needed depending on how you configured your shell.\n\nconda init\nconda create -n environment_name\nconda activate environment_name\nmamba install hazelbean\n\n\nYou can now import hazelbean and it will have precompiled binaries already working for your operating system for geospatial operations using ProjectFlow!"
  },
  {
    "objectID": "installation.html#project-installation",
    "href": "installation.html#project-installation",
    "title": "",
    "section": "2. Project Installation",
    "text": "2. Project Installation\nIf someone has given you a project repository that you want to run and it relies on some combination of our devstack tools, but you are not planning on editing any of the tools, a Project Installation is your best approach. Here we will use seals_cgebox_dev as an example project. See also our video tutorial for Project installation."
  },
  {
    "objectID": "installation.html#developer-installation",
    "href": "installation.html#developer-installation",
    "title": "",
    "section": "3. Developer Installation",
    "text": "3. Developer Installation\nIf you want to run SEALS, edit Hazelbean, or run our global_invest models, you will need to have a C compiler and have editable installs of our git repositories. First, do the basic installation above and then follow these steps:\n\nInstall C/C++ compiler\n\nWindows: - Option 1: You could go to https://visualstudio.microsoft.com/visual-cpp-build-tools/ and select download build tools. - Option 2: Enter the following command in the Terminal: winget install Microsoft.VisualStudio.2022.BuildTools --force --override \"--passive --wait --add Microsoft.VisualStudio.Workload.VCTools;includeRecommended\" This will launch the build-tools installer (you could do this manually via the MS website if you want, but this ensures you get the right tools). - Option 3: Run the install.bat file in the Earth Economy Devestack repo’s root. This just runs the winget command above. - Mac:\nMac/Linux\n\nYou can use Xcode to compile the cython files. Most users will already have this installed but if not, follow the directions below.\n\nIf you don’t have Xcode, you can get it by running xcode-select --install in the Terminal. This command downloads and installs the Xcode Command Line Tools, which includes gcc and clang, the compilers needed to compile C/C++ code on macOS. This is somewhat analogous to the Visual Studio Build Tools on Windows.\n\n\n\nClone all desired repositories\n\nTo install one of our repositories, for example SEALS, you start by cloning the repo at https://github.com/jandrewjohnson/seals_dev.\n\nYou can clone it to whatever folder you want, but if you want to switch to a Workspace configuration later, we recommend installing it in /Users//Files// which using the SEALS example on my machine would be C:/Users/jajohns/Files/seals/seals_dev.\nFrom with your command prompt pointing at that directory, run your git command\n\ngit clone https://github.com/jandrewjohnson/&lt;toolname&gt;\n\n\nSupported repositories include the below\n\nhttps://github.com/jandrewjohnson/seals_dev\nhttps://github.com/jandrewjohnson/hazelbean_dev\nhttps://github.com/jandrewjohnson/gtap_invest_dev\nhttps://github.com/jandrewjohnson/global_invest_dev\nhttps://github.com/jandrewjohnson/gtappy_dev\n\n\nInstall the cloned repositories using an “editable” install with pip\n\nActivate the conda environment in this command prompt with the following command\n\nmamba activate environment_name\n\nNavigate in you command prompt to the directory where you cloned the additional repos. For the SEALS example, this would be C:\\Users\\jajohns\\Files\\seals\\seals_dev\nUse pip to install the repo you as an “editable install” with the following command\n\npip install -e . --no-deps\n\n\n\nOne installed, the cloned repositories are all importable by python. For SEALS, you might want to start by poking around run_seals_standard.py."
  },
  {
    "objectID": "installation.html#common-problems",
    "href": "installation.html#common-problems",
    "title": "",
    "section": "Common problems:",
    "text": "Common problems:\n\nYou MUST have administrator rights to your computer.\nIf you’re using Windows PowerShell (instead of the Command Prompt and it isn’t working with Conda, you must initialize conda in powershell\n\nconda init powershell\n\nIf you don’t add conda to your path, you can do this manually. On PC, you could use the command\n\nSETX PATH \"%PATH%;C:\\Users\\&lt;YOUR_USERNAME&gt;\\miniforge3;C:\\Users\\&lt;YOUR_USERNAME&gt;\\miniforge3;\"\n(you can do for All Users, but you will need to manually set paths to conda)\n\nIf you have an Apple “m1 or m2” chip (a relatively new apple chip, make sure you select the Apple Silicon option). - Install in C:\\Users\\&lt;YOUR_USERNAME&gt;\\miniforge3 (PC) or ~/miniconda3 (Mac)\n\n\nIf you get a “Windows Protected your PC”, click more info then Run Anyway."
  }
]